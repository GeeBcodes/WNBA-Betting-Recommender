from sqlalchemy.orm import Session, joinedload
import uuid
from typing import List, Optional

from db import models
from schemas import parlay as parlay_schema

# --- CRUD for Parlay ---
def create_parlay(db: Session, parlay: parlay_schema.ParlayCreate) -> models.Parlay:
    db_parlay = models.Parlay(
        # id is auto-generated by UUID default
        selections=parlay.selections, # Pydantic model_dump could be used if selections were complex Pydantic objects
                                      # but here selections is List[ParlaySelectionDetail] and ParlaySelectionDetail is a simple dict-like structure
                                      # So, direct assignment should work as selections in DB model is JSONB
        combined_probability=parlay.combined_probability,
        total_odds=parlay.total_odds
        # created_at is default in model
        # user_id can be added later if users are implemented
    )
    db.add(db_parlay)
    db.commit()
    db.refresh(db_parlay)
    return db_parlay

def get_parlay(db: Session, parlay_id: uuid.UUID) -> Optional[models.Parlay]:
    """Fetches a single parlay by its ID."""
    return db.query(models.Parlay).filter(models.Parlay.id == parlay_id).first()

def get_parlays(
    db: Session, 
    skip: int = 0, 
    limit: int = 100,
    min_combined_probability: Optional[float] = None,
    min_legs: Optional[int] = None,
    max_legs: Optional[int] = None
) -> List[models.Parlay]:
    """
    Fetches a list of parlays with optional pagination and filtering.
    Filtering by number of legs requires inspecting the JSON 'selections' field.
    """
    query = db.query(models.Parlay)

    if min_combined_probability is not None:
        query = query.filter(models.Parlay.combined_probability >= min_combined_probability)
    
    # Note: Filtering by number of legs (min_legs, max_legs) on a JSONB field 
    # can be database-specific and might be less performant than filtering in Python 
    # if the dataset is not too large or if this query is not frequent.
    # For PostgreSQL, you might use jsonb_array_length.
    # For simplicity here, we'll retrieve and then filter in Python if these are provided, 
    # or acknowledge this as a potential area for DB-specific optimization.

    parlays = query.order_by(models.Parlay.created_at.desc()).offset(skip).limit(limit).all()

    # Python-side filtering for number of legs if criteria are given
    if min_legs is not None:
        parlays = [p for p in parlays if len(p.selections) >= min_legs]
    
    if max_legs is not None:
        parlays = [p for p in parlays if len(p.selections) <= max_legs]
        
    return parlays 