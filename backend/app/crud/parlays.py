import sqlalchemy # Add this line to suppress Pylance import error if select is not found below
from sqlalchemy.ext.asyncio import AsyncSession # Add this
from sqlalchemy import select # Add this
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import List, Optional

from backend.db import models
from backend.schemas import parlay as parlay_schema

# --- CRUD for Parlay ---
async def create_parlay(db: AsyncSession, parlay: parlay_schema.ParlayCreate) -> models.Parlay:
    db_parlay = models.Parlay(
        # id is auto-generated by UUID default
        selections=[sel.model_dump() for sel in parlay.selections], # Convert Pydantic models to dicts
                                      # but here selections is List[ParlaySelectionDetail] and ParlaySelectionDetail is a simple dict-like structure
                                      # So, direct assignment should work as selections in DB model is JSONB
        combined_probability=parlay.combined_probability,
        total_odds=parlay.total_odds
        # created_at is default in model
        # user_id can be added later if users are implemented
    )
    db.add(db_parlay)
    await db.commit()
    await db.refresh(db_parlay)
    return db_parlay

async def get_parlay(db: AsyncSession, parlay_id: uuid.UUID) -> Optional[models.Parlay]:
    """Fetches a single parlay by its ID."""
    stmt = select(models.Parlay).filter(models.Parlay.id == parlay_id)
    result = await db.execute(stmt)
    return result.scalars().first()

async def get_parlays(
    db: AsyncSession, 
    skip: int = 0, 
    limit: int = 100,
    min_combined_probability: Optional[float] = None,
    min_legs: Optional[int] = None,
    max_legs: Optional[int] = None
) -> List[models.Parlay]:
    """
    Fetches a list of parlays with optional pagination and filtering.
    Filtering by number of legs requires inspecting the JSON 'selections' field.
    """
    query = select(models.Parlay)

    if min_combined_probability is not None:
        query = query.filter(models.Parlay.combined_probability >= min_combined_probability)
    
    # Note: Filtering by number of legs (min_legs, max_legs) on a JSONB field 
    # can be database-specific and might be less performant than filtering in Python 
    # if the dataset is not too large or if this query is not frequent.
    # For PostgreSQL, you might use jsonb_array_length.
    # For simplicity here, we'll retrieve and then filter in Python if these are provided, 
    # or acknowledge this as a potential area for DB-specific optimization.

    stmt = query.order_by(models.Parlay.created_at.desc()).offset(skip).limit(limit)
    result = await db.execute(stmt)
    parlays = result.scalars().all()

    # Python-side filtering for number of legs if criteria are given
    if min_legs is not None:
        parlays = [p for p in parlays if len(p.selections) >= min_legs]
    
    if max_legs is not None:
        parlays = [p for p in parlays if len(p.selections) <= max_legs]
        
    return parlays 